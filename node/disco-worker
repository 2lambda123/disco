#!/usr/bin/env python
import os, sys

from disconode import disco_worker
from disco.fileutils import ensure_path, ensure_file 
from disco.netstring import decode_netstring_fd
from disco.util import msg, err, data_err
from disco import comm


def run(task, jobpack):
        method = getattr(disco_worker, 'op_' + task.mode, None)
        if method is None:
                err("Invalid operation: %s" % task.mode)
        
        if int(jobpack['profile']):
                try:
                        import cProfile as prof
                except:
                        import profile as prof

                key = "profile-%s-%s" % (task.mode, task.id)
                prof.run("method(m)", task.path(key)[0])
                # value = None below because profiler produces the
                # file 'key'.
                disco_worker.put(key, None) 
        else:
                method(jobpack)

if __name__ == "__main__":
        if len(sys.argv) < 7:
                err("Invalid command line. "\
                     "Usage: disco_worker [map|reduce] "\
                     "name hostname master_url partid inputs..")

        # Announce my PID to the master
        print >> sys.stderr, "**<PID>%s" % os.getpid()
        
        mode = sys.argv[1]
        name = sys.argv[2]
        host = sys.argv[3]
        master = sys.argv[4]
        part = sys.argv[5]
        inputs = sys.argv[6:]

        disco_worker.init(mode, host, master, name, part, inputs) 
        task = disco_worker.Task

        try: 
                ensure_path(task.path("OOB_FILE", "")[0], False)
                os.chdir(task.path("CHDIR_PATH")[0])
        except Exception, e:
                data_err("Failed to initialize worker directories "\
                                "(disk full?)", "")
        
        try:
                if task.has_flag("resultfs"):
                        url = "%s/data/%s/params" % (task.root, "/".join(\
                                master.strip("/").split("/")[-3:]))
                        fn = lambda: file(url).read()
                else:
                        url = "%s/params" % master
                        fn = lambda: comm.download(url)
                ensure_file(task.path("PARAMS_FILE")[0], fn, mode = 444)
        except Exception, e:
                data_err("Failed to get %s: %s" % (url, e), master)

        try:
                m = decode_netstring_fd(file(task.path("PARAMS_FILE")[0]))
        except Exception, e:
                data_err("Decoding the job description failed", master)
        
        my_ver = ".".join(map(str, sys.version_info[:2]))
        if m["version"] != my_ver:
                data_err("Python version mismatch: client = %s vs. node = %s" %\
                                (m["version"], my_ver), "")
                sys.exit(1)

        try:
                run(task, m)
        except comm.CommException, x:
                # check the number of open file descriptors (under proc), warn
                # if close to max
                # http://stackoverflow.com/questions/899038/getting-the-highest-allocated-file-descriptor
                data_err("HTTP error: %s" % x, "")
        except IOError, x:
                # check the number of open file descriptors (under proc)
                # if close to max
                # http://stackoverflow.com/questions/899038/getting-the-highest-allocated-file-descriptor
                data_err("IO error: %s" % x, "")
        
        msg("Worker done", "END")
